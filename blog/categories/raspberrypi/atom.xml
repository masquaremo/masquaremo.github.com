<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RaspberryPi | φ(. . )めもめも]]></title>
  <link href="http://masquaremo.github.com/blog/categories/raspberrypi/atom.xml" rel="self"/>
  <link href="http://masquaremo.github.com/"/>
  <updated>2013-01-27T21:03:40+09:00</updated>
  <id>http://masquaremo.github.com/</id>
  <author>
    <name><![CDATA[masquaremo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RaspberryPi - C言語でLチカ(レジスタ直接制御)]]></title>
    <link href="http://masquaremo.github.com/blog/2013/01/27/201355/"/>
    <updated>2013-01-27T20:13:00+09:00</updated>
    <id>http://masquaremo.github.com/blog/2013/01/27/201355</id>
    <content type="html"><![CDATA[<p>雑誌インターフェース 2012年12月号の
<a href="http://www.cqpub.co.jp/interface/download/contents.htm">サンプルプログラム</a>
(おそらくオリジナルは<a href="http://elinux.org/RPi_Low-level_peripherals#GPIO_Driving_Example_.28C.29">ここ</a>)を、
Rev2基板用にすこし修正して動作させた。(48行目～)<br/>
それと、サンプルプログラムのGPIO4がなぜか無効になっていた(何故？)ので使えるように。</p>

<p>Rev2のピンヘッダのGPIO情報は<a href="http://elinux.org/RPi_Low-level_peripherals#General_Purpose_Input.2FOutput_.28GPIO.29">こちら</a>の少し下あたり。</p>

<pre><code>gcc gpio_c.c
sudo ./a.out
</code></pre>

<h2>レジスタへのアクセス動作のしくみ</h2>

<ol>
<li>malloc()で、仮想メモリ空間のメモリ領域を確保</li>
<li>/dev/mem と mmap()で、確保したメモリ領域をレジスタ領域にマッピング</li>
<li>mmap()がレジスタのアドレスを返す</li>
<li>mmap()が返したアドレス＋オフセットで各レジスタにアクセスする</li>
</ol>


<p><div><script src='https://gist.github.com/4647697.js'></script>
<noscript><pre><code>//
//  How to access GPIO registers from C-code on the Raspberry-Pi
//  Example program
//  15-January-2012
//  Dom and Gert
//


// Access from ARM Running Linux

#define BCM2708_PERI_BASE        0x20000000
#define GPIO_BASE                (BCM2708_PERI_BASE + 0x200000) /* GPIO controller */


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;unistd.h&gt;

#define PAGE_SIZE (4*1024)
#define BLOCK_SIZE (4*1024)

int  mem_fd;
char *gpio_mem, *gpio_map;
char *spi0_mem, *spi0_map;


// I/O access
volatile unsigned *gpio;


// GPIO setup macros. Always use INP_GPIO(x) before using OUT_GPIO(x) or SET_GPIO_ALT(x,y)
#define INP_GPIO(g) *(gpio+((g)/10)) &amp;= ~(7&lt;&lt;(((g)%10)*3))
#define OUT_GPIO(g) *(gpio+((g)/10)) |=  (1&lt;&lt;(((g)%10)*3))
#define SET_GPIO_ALT(g,a) *(gpio+(((g)/10))) |= (((a)&lt;=3?(a)+4:(a)==4?3:2)&lt;&lt;(((g)%10)*3))

#define GPIO_SET *(gpio+7)  // sets   bits which are 1 ignores bits which are 0
#define GPIO_CLR *(gpio+10) // clears bits which are 1 ignores bits which are 0
#define GPIO_GET *(gpio+13) // read   bits

#define REV2 // for rev2 board
#ifdef REV2
#define  MAX_PORTNUM	27
char valid_port[] = {
 0,0,1,1, // 0..3
 1,0,0,1, // 4..7
 1,1,1,1, // 8..11
 0,0,1,1, // 12..15
 0,1,1,0, // 16..19
 0,0,1,1, // 20..23
 1,1,0,1, // 24..27
};
#else
#define	MAX_PORTNUM	25
char valid_port[] = {
 1,1,0,0,
 0,0,0,1,
 1,1,1,1,
 0,0,1,1,
 0,1,1,0,
 0,1,1,1,
 1,1
};
#endif

void setup_io();

int port_avail(int port)
{
	if ((port &lt; 0) || (port &gt; MAX_PORTNUM))
		return (0);
	return ((int)valid_port[port]);
}

int gpio_read(int port)
{
	if (!port_avail(port))
		return(0);
	return( (GPIO_GET &amp; (1&lt;&lt;port)) ? 1 : 0);
}

void gpio_write(int port, int data)
{
	if (!port_avail(port)) {
        printf(&quot;illigal port:%d\n&quot;, port);
		return;
    }
	if (data == 0)
		GPIO_CLR = 1&lt;&lt;port;
	else
        GPIO_SET = 1&lt;&lt;port;
}

//
// Set up a memory regions to access GPIO
//
int initcount= 0;
void setup_io()
{
	initcount++;
   /* open /dev/mem */
   if ((mem_fd = open(&quot;/dev/mem&quot;, O_RDWR|O_SYNC) ) &lt; 0) {
      printf(&quot;can't open /dev/mem \n&quot;);
      exit (-1);
   }

   /* mmap GPIO */

   // Allocate MAP block
   if ((gpio_mem = malloc(BLOCK_SIZE + (PAGE_SIZE-1))) == NULL) {
      printf(&quot;allocation error \n&quot;);
      exit (-1);
   }

   // Make sure pointer is on 4K boundary
   if ((unsigned long)gpio_mem % PAGE_SIZE)
     gpio_mem += PAGE_SIZE - ((unsigned long)gpio_mem % PAGE_SIZE);

   // Now map it
   gpio_map = (char *)mmap(
      (caddr_t)gpio_mem,
      BLOCK_SIZE,
      PROT_READ|PROT_WRITE,
      MAP_SHARED|MAP_FIXED,
      mem_fd,
      GPIO_BASE
   );

   if ((long)gpio_map &lt; 0) {
      printf(&quot;mmap error %d\n&quot;, (int)gpio_map);
      exit (-1);
   }

   // Always use volatile pointer!
   gpio = (volatile unsigned *)gpio_map;


} // setup_io

void gpio_init()
{
	int i;
	setup_io();
#if 1 // modify. test gpio4
    INP_GPIO(4); // must use INP_GPIO before we can use OUT_GPIO
    OUT_GPIO(4);
#else
    for (i=0; i&lt;1; i++) {
		INP_GPIO(i);
	}
	for (i=7; i&lt;=11; i++) {
		INP_GPIO(i); // must use INP_GPIO before we can use OUT_GPIO
		OUT_GPIO(i);
	}
#endif
}


void testmain()
{
#if 1 // modify. test gpio4
    int i;
    for(i = 0; i &lt; 10; i++) {
        gpio_write(4, 1);
        sleep(1);
        gpio_write(4, 0);
        sleep(1);
    }
#else
    int p;
    for (p=7; p&lt;=11; p++) {
       gpio_write(p,1);
	sleep(1);
     }
     for (p=0; p&lt;2; p++) {
	printf(&quot;%d:&quot;,gpio_read(p));
     }
     printf(&quot;\n&quot;);
     for (p=7; p&lt;=11; p++) {
       gpio_write(p,0);
       sleep(1);
     }
     for (p=0; p&lt;2; p++) {
	printf(&quot;%d:&quot;,gpio_read(p));
     }
     printf(&quot;\n&quot;);
#endif
}

int main(int argc, char **argv)
{ 
 
	gpio_init();
	testmain();
	return 0;
} // main
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RaspberryPi - CRubyでLチカ]]></title>
    <link href="http://masquaremo.github.com/blog/2013/01/26/raspi_gpio_ruby/"/>
    <updated>2013-01-26T15:00:00+09:00</updated>
    <id>http://masquaremo.github.com/blog/2013/01/26/raspi_gpio_ruby</id>
    <content type="html"><![CDATA[<p>デバイスファイルを使用した、GPIO制御。</p>

<p><div><script src='https://gist.github.com/4635396.js'></script>
<noscript><pre><code>system('echo &quot;4&quot; &gt; /sys/class/gpio/export')
system('echo &quot;out&quot; &gt; /sys/class/gpio/gpio4/direction')
[0, 1].cycle do |sw|
  system(&quot;echo #{sw} &gt; /sys/class/gpio/gpio4/value&quot;)
  sleep(0.5)
end
</code></pre></noscript></div>
</p>

<pre><code>sudo ruby gpio4.rb
</code></pre>

<p><img src="http://dl.dropbox.com/u/54355699/github/raspi01.JPG" alt="RubyでLチカ" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RaspberryPi - CRubyとmrubyのインストール]]></title>
    <link href="http://masquaremo.github.com/blog/2013/01/26/raspi_install_ruby/"/>
    <updated>2013-01-26T08:20:00+09:00</updated>
    <id>http://masquaremo.github.com/blog/2013/01/26/raspi_install_ruby</id>
    <content type="html"><![CDATA[<h2>環境</h2>

<ul>
<li><a href="http://www.raspberrypi.org/downloads">Raspbian "wheezy' 2012-12-16版</a></li>
</ul>


<p>事前に</p>

<pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>

<p>を実施済み</p>

<h2>gitのインストール</h2>

<pre><code>sudo apt-get install git-core
</code></pre>

<h2>CRubyのインストール</h2>

<pre><code>sudo apt-get install ruby
</code></pre>

<h2>mrubyのインストール・ビルド</h2>

<pre><code>git clone git://github.com/mruby/mruby.git
sudo apt-get install build-essential bison
</code></pre>

<p>mrubyディレクトリ下で</p>

<pre><code>make
</code></pre>

<p>※先にCRubyを入れていないと途中でエラーになる</p>

<h2>環境変数</h2>

<pre><code>export MRUBY_HOME=(makeしたディレクトリ)  
export PATH=$PATH:$MRUBY_HOME/bin  
</code></pre>

<p>※.bashrcにも</p>

<h2>参考サイト</h2>

<p><a href="http://geekmonkey.org/articles/37-building-mruby-on-the-raspberry-pi">http://geekmonkey.org/articles/37-building-mruby-on-the-raspberry-pi</a></p>
]]></content>
  </entry>
  
</feed>
